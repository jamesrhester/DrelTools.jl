var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide-to-using-CIF_dREL","page":"Guide","title":"Guide to using CIF_dREL","text":"","category":"section"},{"location":"guide/#Introduction","page":"Guide","title":"Introduction","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"CIF_dREL provides methods and types that take advantage of code embedded in CIF dictionaries (ontologies) that describes mathematical relationships between data names defined in those ontologies. To do this, it translates those methods into Julia code that can be executed, for example, to find or check missing values.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Before reading the following, you should be familiar with  the CrystalInfoFramework.jl documentation for working with CIF files and dictionaries.","category":"page"},{"location":"guide/#Usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"guide/#Preparation","page":"Guide","title":"Preparation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Read in the CIF dictionary, and prepare any dREL functions defined in the dictionary:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"dict = DDLm_Dictionary(\"cif_core.dic\")\ndefine_dict_funcs!(dict)    #add dREL Functions to dictionary","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"In DDLm, dREL functions are defined in categories that have _definition.class of Function. They should not be confused with dREL methods, which are associated with particular data names or categories.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The DDLm_Dictionary type used above is defined in CrystalInfoFramework.jl. DDL2_Dictionarys may also be used, but only methods of type dREL will be recognised.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"define_dict_funcs! will process all dREL functions found in the dictionary and make them available to dREL methods. They can be inspected via the  CrystalInfoFramework get_dict_func method.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"dREL methods operate on any source of data that returns the correct data types and has a relational structure.  We use a  CrystalInfoFramework TypedDataSource created from a CIF block:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"n = Cif(\"nick1.cif\")\nb = n[\"saly2_all_aniso\"] #select a data block\nt = TypedDataSource(b,dict)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The final step is to create a DynamicDDLmRC type that allows new values to be derived given a dictionary describing the mathematical relationships:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"dd = DynamicDDLmRC(t,dict)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Note that in this case the dictionary used for typing, and the dictionary used for dREL methods and to create the relational structure, are the same dictionary.","category":"page"},{"location":"guide/#Derivation","page":"Guide","title":"Derivation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"A request for a data name whose value is not found in the DynamicDDLmRC object will trigger derivation:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"dd[\"_cell.volume\"]","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"A whole category may also be computed if the values needed for the calculation are present:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"dd[\"geom_bond\"]","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Note that, as computations (currently) can take significant time, results are cached. To clear this cache, call empty_cache!.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"test/drel_exec.jl contains demonstrations of how to make use of dREL scripts found in dictionaries.","category":"page"},{"location":"guide/#Namespaces","page":"Guide","title":"Namespaces","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Advanced users may have DataSources with data names from different namespaces. Provide a further nspace argument to disambiguate in this case:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"dd[\"_cell.volume\",\"CifCore\"]","category":"page"},{"location":"guide/#Translating-dREL","page":"Guide","title":"Translating dREL","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If you wish simply to transform some dREL code into Julia, you can use make_julia_code.  You will need to provide the dREL fragment, the data name it is associated with (or category name), and the CIF dictionary. The returned Expr will need to be evaluated and assigned to a variable before it can be executed. The arguments to the returned function are the datablock and a single row of the category to which the defined value belongs.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"dreltext = \"\"\"\n      With c  as  cell\n \n      _cell.volume =  c.vector_a * ( c.vector_b ^ c.vector_c )\n\n\"\"\"\nmake_julia_code(dreltext,\"_cell.volume\",dict)\n\n# output\n\nfunction (__datablock::DynamicRelationalContainer, __packet::CatPacket)\n    #= /home/jrh/programs/CIF/dRELTools.jl/src/drel_ast.jl:397 =#\n    __dict = missing\n    c = missing\n    __dreltarget = missing\n    #= /home/jrh/programs/CIF/dRELTools.jl/src/jl_transformer.jl:120 =#\n    #= /home/jrh/programs/CIF/dRELTools.jl/src/jl_transformer.jl:122 =#\n    begin\n        __dict = get_dictionary(__datablock, \"CifCore\")\n        begin\n            c = __packet\n            #= /home/jrh/programs/CIF/dRELTools.jl/src/jl_transformer.jl:651 =#\n            begin\n                __dreltarget = drel_property_access(c, \"vector_a\", __datablock)::drelvector * cross(drel_property_access(c, \"vector_b\", __datablock)::drelvector, drel_property_access(c, \"vector_c\", __datablock)::drelvector)\n            end\n        end\n        return __dreltarget\n    end\nend\n","category":"page"},{"location":"api/#dRELTools-API","page":"API","title":"dRELTools API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DynamicDDLmRC","category":"page"},{"location":"api/#DrelTools.DynamicDDLmRC","page":"API","title":"DrelTools.DynamicDDLmRC","text":"DynamicDDLmRC(ds, dict::AbstractCifDictionary)\n\nCreate a DynamicDDLmRC object from ds with relational structure defined by dict. If dict includes dREL methods describing mathematical relationships between data names, use these to derive and cache missing values.\n\nds should provide the DataSource trait.\n\nA DynamicDDLmRC is itself a DataSource.\n\n\n\n\n\n","category":"type"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"define_dict_funcs!(dict)\nempty_cache!(d::DynamicDDLmRC)\nkeys(d::DynamicDDLmRC)\nhaskey(d::DynamicDDLmRC,s)\nhaskey(d::DynamicDDLmRC,s,n)\ngetindex(d::DynamicDDLmRC,s)\ngetindex(d::DynamicDDLmRC,s,nspace)\nsetindex!(d::DynamicDDLmRC,v,s)\nsetindex!(d::DynamicDDLmRC,v,s,nspace)\nget_category(d::DynamicDDLmRC,s::AbstractString,nspace::String)\nget_category(d::DynamicDDLmRC,s)\nderive(b::DynamicRelationalContainer,dataname::AbstractString,nspace)","category":"page"},{"location":"api/#DrelTools.define_dict_funcs!-Tuple{Any}","page":"API","title":"DrelTools.define_dict_funcs!","text":"define_dict_funcs!(dict)\n\nFind and transform to Julia all dREL functions defined in dict. This must be called in order for these functions to be available to dREL methods defined in dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#DrelTools.empty_cache!-Tuple{DynamicDDLmRC}","page":"API","title":"DrelTools.empty_cache!","text":"empty_cache!(d)\n\nRemove all cached data name values computed for d.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.keys-Tuple{DynamicDDLmRC}","page":"API","title":"Base.keys","text":"keys(d::DynamicDDLmRC)\n\nReturn all data names that have associated values in d. If multiple namespaces are present, some data names may be duplicated. If calculations have been performed to derive data name values, those data names will be included.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{DynamicDDLmRC,Any}","page":"API","title":"Base.haskey","text":"haskey(d::DynamicDDLmRC,s)\n\ntrue if any instance found of s in d.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{DynamicDDLmRC,Any,Any}","page":"API","title":"Base.haskey","text":"haskey(d::DynamicDDLmRC,s,n)\n\ntrue if any instance found of s from namespace n in d.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DynamicDDLmRC,Any}","page":"API","title":"Base.getindex","text":"getindex(d::DynamicDDLmRC,s)\n\nd[s] returns all values for that data name in the same order as the key values, so that they may be interpreted as a column of values in correct order, deriving missing values from dREL methods if available.\n\nIf s appears in multiple namespaces within d, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DynamicDDLmRC,Any,Any}","page":"API","title":"Base.getindex","text":"getindex(d::DynamicDDLmRC,s,nspace)\n\nd[s,nspace] returns the values of dataname s from namespace nspace in d, with derivation of missing values. Values are returned in an order corresponding to the order in which key data name values are provided, meaning that the returned values can be assembled into a table without further manipulation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{DynamicDDLmRC,Any,Any}","page":"API","title":"Base.setindex!","text":"setindex!(d::DynamicDDLmRC,v,s)\n\nSet the value of s in d to v. The underlying data source is not changed, instead values are set in the cache and will be deleted by empty_cache!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{DynamicDDLmRC,Any,Any,Any}","page":"API","title":"Base.setindex!","text":"setindex!(d::DynamicDDLmRC,v,s,nspace)\n\nSet the value of s from namespace nspace in d to v.  The underlying data source is not changed, instead values are set in the cache and will be deleted by empty_cache!.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.DataContainer.get_category-Tuple{DynamicDDLmRC,AbstractString,String}","page":"API","title":"CrystalInfoFramework.DataContainer.get_category","text":"get_category(d::DynamicDDLmRC,s::AbstractString,nspace::String)\n\nReturn a CifCategory named s in namespace nspace from d, creating the category using dREL category methods if missing. If s is already present, no further data names from that category are derived.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.DataContainer.get_category-Tuple{DynamicDDLmRC,Any}","page":"API","title":"CrystalInfoFramework.DataContainer.get_category","text":"get_category(d::DynamicDDLmRC,s)\n\nReturn a CifCategory named s from d, creating the category using dREL category methods if missing. If s is already present, no further data names from that category are derived. If s is ambiguous because it is  present in multiple namespaces, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"api/#DrelTools.derive-Tuple{DynamicRelationalContainer,AbstractString,Any}","page":"API","title":"DrelTools.derive","text":"derive(b::DynamicRelationalContainer,dataname,nspace)\n\nDerive values for dataname in nspace missing from b. Return missing if the category itself is missing, otherwise return an Array potentially containing missing values with one value for each row in the category.\n\n\n\n\n\n","category":"method"},{"location":"api/#For-developers","page":"API","title":"For developers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"make_julia_code(drel_text,dataname,dict; reserved=AbstractString[])\nadd_definition_func!(d,s)","category":"page"},{"location":"api/#DrelTools.make_julia_code-Tuple{Any,Any,Any}","page":"API","title":"DrelTools.make_julia_code","text":"make_julia_code(drel_text,dataname,dict; reserved=[])\n\nDefine a Julia method from dREL code contained in drel_text which calculates the value of dataname defined in dict. All category names in dict and any additional names in reserved are recognised as categories.\n\n\n\n\n\n","category":"method"},{"location":"api/#DrelTools.add_definition_func!-Tuple{Any,Any}","page":"API","title":"DrelTools.add_definition_func!","text":"add_definition_func!(dictionary,dataname)\n\nAdd a method that adjusts the definition of dataname by defining a DDLm attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Drel-runtime-functions","page":"API","title":"Drel runtime functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following methods are defined to be used within Julia code generated from dREL in order to support dREl semantics and recursive calculation.","category":"page"},{"location":"api/","page":"API","title":"API","text":"drelvector\nDrelTable\nDrelTools.drel_property_access(cp,obj,datablock::DynamicRelationalContainer)","category":"page"},{"location":"api/#DrelTools.drelvector","page":"API","title":"DrelTools.drelvector","text":"A drelvector is a vector which adopts the correct dimension (column or row) to allow pre or post multiplication without explicit transposition. \n\n\n\n\n\n","category":"type"},{"location":"api/#DrelTools.DrelTable","page":"API","title":"DrelTools.DrelTable","text":"A DrelTable is almost like a Julia Dict, but it must allow CaselessString comparisons with String, and the types of the keys are restricted.\n\n\n\n\n\n","category":"type"},{"location":"api/#DrelTools.drel_property_access-Tuple{Any,Any,DynamicRelationalContainer}","page":"API","title":"DrelTools.drel_property_access","text":"drel_property_access(cp,obj,datablock)\n\nThis call corresponds to cp.obj in dREL code. If obj is not a property of cp, datablock is used to try to derive a value, returning missing for all failures and caching the result in datablock if successful.\n\n\n\n\n\n","category":"method"},{"location":"#CIF_dREL:-A-dREL-to-Julia-translator","page":"Overview","title":"CIF_dREL: A dREL to Julia translator","text":"","category":"section"},{"location":"#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"dREL (J. Chem. Inf. Model., 2012, 52 (8), pp 1917â€“1925 DOI: 10.1021/ci300076w) is a machine-readable language for describing the relationships between data names defined in a CIF (Crystallographic Information Framework) dictionary.  Examples of dREL use can be found in  the latest CIF core dictionary.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This package is experimental.  Method and type names are subject to change. It is likely to run a lot faster in the future as optimisations are implemented.  Suggestions on speed improvement and new functionality are welcome.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Install Julia.  At the Pkg prompt (ie after entering ]) type add CIF_dREL.  Simply put using CIF_dREL at the top of any Julia code that uses methods from this package.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Note that CIF dictionary support is provided by the  CrystalInfoFramework  package, which will be installed together with CIF_dREL.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Please advise of any difficulties in installation so that either these instructions or the installation setup can be improved.","category":"page"},{"location":"#Note","page":"Overview","title":"Note","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The deps directory contains a short script to pre-build the dREL grammar. When changing the grammar this should be re-run. There is no harm in executing this script after installation: julia build.jl","category":"page"}]
}
